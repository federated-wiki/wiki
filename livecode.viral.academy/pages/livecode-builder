{"journal":[{"date":1427398338385,"item":{"story":"","title":"LiveCode Builder"},"type":"create"},{"date":1427398339840,"id":"4d93155e1ba7b90b","item":{"id":"4d93155e1ba7b90b","type":"factory"},"type":"add"},{"date":1427398343083,"id":"4d93155e1ba7b90b","item":{"id":"4d93155e1ba7b90b","text":"Well, there will be a new dialect of LiveCode in which you will be able to write things called extensions. An extension will (in the first instance) either be a library or a widget.\n\nLibraries are collections of commands and functions that integrate into the engine in exactly the same way as engine commands and functions do (the only caveat being initially is that you will be restricted to generic function / command call syntax to access them ‚Äì full and proper syntax bindings will have to wait until Open Language is born).\n\nWidgets are collections of commands, functions and event handlers ‚Äì these will be used by a new control type widget and allow you to create you own controls which look, feel and act as if they were in fact part of the engine itself. Indeed, widgets will be very familiar to anyone who has ever written a control in Visual Basic, Delphi, or derived a new control from the base control class in any of the multiplicity of C++ GUI frameworks. This idea of controls is different from the aggregate style of custom control we currently see in LiveCode ‚Äì rather than using a container in which you put other controls you instead get a ‚Äòpaint‚Äô event and all the basic interaction events you need to craft your control entirely the way you want. To help you do this, you‚Äôll also have access to an array of functionality crafted for the task ‚Äì most importantly, you‚Äôll be able to use a collection of syntax that provides 2d vector drawing capabilities along the lines of the HTML5 Canvas, or CoreGraphics library to draw your widgets.\n\nI mentioned above that this will be based upon a ‚Äònew dialect‚Äô of LiveCode (I‚Äôm currently calling it LiveCodeish) but this shouldn‚Äôt cause alarm bells (hopefully, at least). Essentially the dialect will be a distilled form of the current LiveCode core syntax and semantics ‚Äì this syntax will be cleaned up and its functionality will be much better defined (for example, getting rid of auto-conversion of arrays to empty strings and ‚Äòfixing‚Äô the non-standard ‚Äòfor x to y‚Äô loop we have). The main aim of this clean up is to ensure we have a solid, predictable, reliable and completely defined base to work from without having to worry about any hangovers from the (very much organically evolved) past.\n\n[ I think it is important for me to mention is that we do not intend there to be two LiveCode languages - the language you use for extensions (what I‚Äôm calling LiveCodeish) and the language you use in object scripts. It is our intention that there will be one, and only one, LiveCode - the object script language will also move to LiveCodeish, once we‚Äôre happy we‚Äôve got LiveCodeish right (and don‚Äôt worry, when LiveCodeish does arrive at the LiveCode script level your existing scripts will all continue to run as they do now and you‚Äôll be able to translate them automatically over time as needed with the script translation tool we are planning as part of the syntax cleanup project that will be enabled by Open Language). ]\n\nThere are perhaps three aspects of this proposed new LiveCodeish language which deserve mention.\n\nThe first is that this new dialect will provide the ability to directly hook into native code through binding to functions in native code (whether that be Java, Objective-C or C/C++) thus, hopefully, eliminating the need to write ‚Äòglue-code‚Äô externals and, again, making extending LiveCode much more accessible to anyone that can code in LiveCode rather than those few who can, or have the time to delve into these lower-level environments.\n\nThe next is that it will (eventually) be typed in a very natural way. You will be able to declare variables and handler parameters as having a given type (by default their type will be any). Whenever you try to assign a value to the variable the engine will attempt to convert it to the appropriate type and only throw an error if this is not possible. For example a variable with an integer type can have an integer put into it directly, a real number can be put into it after its been automatically rounded, and even a string can ‚Äì as long as the string can be converted to an integer. This simple ability will mean that it will be easier to write ‚Äòcorrect‚Äô code ‚Äì you‚Äôll be able to much more easily debug things where it could be type-mismatches that are causing errors. It also means that (in the future) suitably typed code will run more efficiently ‚Äì for example if you have an integer variable then that can be much more efficiently represented internally than a variable which can hold any type.\n\nThe third thing about LiveCodeish which is quite different from normal LiveCode scripts is that there is no message path ‚Äì well, the message path is there, it‚Äôs just that command and functions in extensions do not sit in it. This is exactly the same situation as current engine commands and functions ‚Äì they are bound at compile time. This not sitting in the message path does not mean that extensions have no access to it, quite the reverse as they will have access in the same way as engine syntax does ‚Äì you will be able to send messages to objects through the message path just as the engine can. This slight change in perspective brings LiveCodeish much closer to more ‚Äòtraditional‚Äô languages ‚Äì and means that over time a much larger range of optimization potential becomes available (as things are more static in this world ‚Äì dynamicity is great, except when you want to optimize at compile time!). Indeed, I can see no reason that LiveCodeish should not be eventually compilable to native code with performance at a level where the decision to code something in C or LiveCodeish due to that metric is a non-issue ‚Äì LiveCodeish will be amply able.","type":"paragraph"},"type":"edit"},{"date":1427398389193,"id":"4d93155e1ba7b90b","item":{"id":"4d93155e1ba7b90b","text":"Well, there will be a new dialect of LiveCode in which you will be able to write things called extensions. An extension will (in the first instance) either be a library or a widget - [http://livecode.com/the-present-and-future-livecode/ livecode.com]","type":"paragraph"},"type":"edit"},{"after":"4d93155e1ba7b90b","date":1427398392776,"id":"afddcba834ce05ba","item":{"id":"afddcba834ce05ba","text":"Libraries are collections of commands and functions that integrate into the engine in exactly the same way as engine commands and functions do (the only caveat being initially is that you will be restricted to generic function / command call syntax to access them ‚Äì full and proper syntax bindings will have to wait until Open Language is born).","type":"paragraph"},"type":"add"},{"after":"afddcba834ce05ba","date":1427398399195,"id":"342b2f5e5d370ada","item":{"id":"342b2f5e5d370ada","text":"Widgets are collections of commands, functions and event handlers ‚Äì these will be used by a new control type widget and allow you to create you own controls which look, feel and act as if they were in fact part of the engine itself. Indeed, widgets will be very familiar to anyone who has ever written a control in Visual Basic, Delphi, or derived a new control from the base control class in any of the multiplicity of C++ GUI frameworks. This idea of controls is different from the aggregate style of custom control we currently see in LiveCode ‚Äì rather than using a container in which you put other controls you instead get a ‚Äòpaint‚Äô event and all the basic interaction events you need to craft your control entirely the way you want. To help you do this, you‚Äôll also have access to an array of functionality crafted for the task ‚Äì most importantly, you‚Äôll be able to use a collection of syntax that provides 2d vector drawing capabilities along the lines of the HTML5 Canvas, or CoreGraphics library to draw your widgets.","type":"paragraph"},"type":"add"},{"after":"342b2f5e5d370ada","date":1427398406976,"id":"4bc105c8384b3034","item":{"id":"4bc105c8384b3034","text":"I mentioned above that this will be based upon a ‚Äònew dialect‚Äô of LiveCode (I‚Äôm currently calling it LiveCodeish) but this shouldn‚Äôt cause alarm bells (hopefully, at least). Essentially the dialect will be a distilled form of the current LiveCode core syntax and semantics ‚Äì this syntax will be cleaned up and its functionality will be much better defined (for example, getting rid of auto-conversion of arrays to empty strings and ‚Äòfixing‚Äô the non-standard ‚Äòfor x to y‚Äô loop we have). The main aim of this clean up is to ensure we have a solid, predictable, reliable and completely defined base to work from without having to worry about any hangovers from the (very much organically evolved) past.","type":"paragraph"},"type":"add"},{"after":"4bc105c8384b3034","date":1427398410088,"id":"f5a94b223227d9a5","item":{"id":"f5a94b223227d9a5","text":"[ I think it is important for me to mention is that we do not intend there to be two LiveCode languages - the language you use for extensions (what I‚Äôm calling LiveCodeish) and the language you use in object scripts. It is our intention that there will be one, and only one, LiveCode - the object script language will also move to LiveCodeish, once we‚Äôre happy we‚Äôve got LiveCodeish right (and don‚Äôt worry, when LiveCodeish does arrive at the LiveCode script level your existing scripts will all continue to run as they do now and you‚Äôll be able to translate them automatically over time as needed with the script translation tool we are planning as part of the syntax cleanup project that will be enabled by Open Language). ]\n\nThere are perhaps three aspects of this proposed new LiveCodeish language which deserve mention.\n\nThe first is that this new dialect will provide the ability to directly hook into native code through binding to functions in native code (whether that be Java, Objective-C or C/C++) thus, hopefully, eliminating the need to write ‚Äòglue-code‚Äô externals and, again, making extending LiveCode much more accessible to anyone that can code in LiveCode rather than those few who can, or have the time to delve into these lower-level environments.\n\nThe next is that it will (eventually) be typed in a very natural way. You will be able to declare variables and handler parameters as having a given type (by default their type will be any). Whenever you try to assign a value to the variable the engine will attempt to convert it to the appropriate type and only throw an error if this is not possible. For example a variable with an integer type can have an integer put into it directly, a real number can be put into it after its been automatically rounded, and even a string can ‚Äì as long as the string can be converted to an integer. This simple ability will mean that it will be easier to write ‚Äòcorrect‚Äô code ‚Äì you‚Äôll be able to much more easily debug things where it could be type-mismatches that are causing errors. It also means that (in the future) suitably typed code will run more efficiently ‚Äì for example if you have an integer variable then that can be much more efficiently represented internally than a variable which can hold any type.\n\nThe third thing about LiveCodeish which is quite different from normal LiveCode scripts is that there is no message path ‚Äì well, the message path is there, it‚Äôs just that command and functions in extensions do not sit in it. This is exactly the same situation as current engine commands and functions ‚Äì they are bound at compile time. This not sitting in the message path does not mean that extensions have no access to it, quite the reverse as they will have access in the same way as engine syntax does ‚Äì you will be able to send messages to objects through the message path just as the engine can. This slight change in perspective brings LiveCodeish much closer to more ‚Äòtraditional‚Äô languages ‚Äì and means that over time a much larger range of optimization potential becomes available (as things are more static in this world ‚Äì dynamicity is great, except when you want to optimize at compile time!). Indeed, I can see no reason that LiveCodeish should not be eventually compilable to native code with performance at a level where the decision to code something in C or LiveCodeish due to that metric is a non-issue ‚Äì LiveCodeish will be amply able.","type":"paragraph"},"type":"add"},{"date":1427398440946,"id":"f5a94b223227d9a5","item":{"id":"f5a94b223227d9a5","text":"[ I think it is important for me to mention is that we do not intend there to be two LiveCode languages - the language you use for extensions (what I‚Äôm calling LiveCodeish) and the language you use in object scripts. It is our intention that there will be one, and only one, LiveCode - the object script language will also move to LiveCodeish, once we‚Äôre happy we‚Äôve got LiveCodeish right (and don‚Äôt worry, when LiveCodeish does arrive at the LiveCode script level your existing scripts will all continue to run as they do now and you‚Äôll be able to translate them automatically over time as needed with the script translation tool we are planning as part of the syntax cleanup project that will be enabled by [[Open Language]]). ]","type":"paragraph"},"type":"edit"},{"after":"f5a94b223227d9a5","date":1427398449422,"id":"c133a85c1c0a355a","item":{"id":"c133a85c1c0a355a","text":"There are perhaps three aspects of this proposed new LiveCodeish language which deserve mention.\n\nThe first is that this new dialect will provide the ability to directly hook into native code through binding to functions in native code (whether that be Java, Objective-C or C/C++) thus, hopefully, eliminating the need to write ‚Äòglue-code‚Äô externals and, again, making extending LiveCode much more accessible to anyone that can code in LiveCode rather than those few who can, or have the time to delve into these lower-level environments.\n\nThe next is that it will (eventually) be typed in a very natural way. You will be able to declare variables and handler parameters as having a given type (by default their type will be any). Whenever you try to assign a value to the variable the engine will attempt to convert it to the appropriate type and only throw an error if this is not possible. For example a variable with an integer type can have an integer put into it directly, a real number can be put into it after its been automatically rounded, and even a string can ‚Äì as long as the string can be converted to an integer. This simple ability will mean that it will be easier to write ‚Äòcorrect‚Äô code ‚Äì you‚Äôll be able to much more easily debug things where it could be type-mismatches that are causing errors. It also means that (in the future) suitably typed code will run more efficiently ‚Äì for example if you have an integer variable then that can be much more efficiently represented internally than a variable which can hold any type.\n\nThe third thing about LiveCodeish which is quite different from normal LiveCode scripts is that there is no message path ‚Äì well, the message path is there, it‚Äôs just that command and functions in extensions do not sit in it. This is exactly the same situation as current engine commands and functions ‚Äì they are bound at compile time. This not sitting in the message path does not mean that extensions have no access to it, quite the reverse as they will have access in the same way as engine syntax does ‚Äì you will be able to send messages to objects through the message path just as the engine can. This slight change in perspective brings LiveCodeish much closer to more ‚Äòtraditional‚Äô languages ‚Äì and means that over time a much larger range of optimization potential becomes available (as things are more static in this world ‚Äì dynamicity is great, except when you want to optimize at compile time!). Indeed, I can see no reason that LiveCodeish should not be eventually compilable to native code with performance at a level where the decision to code something in C or LiveCodeish due to that metric is a non-issue ‚Äì LiveCodeish will be amply able.","type":"paragraph"},"type":"add"}],"story":[{"id":"4d93155e1ba7b90b","text":"Well, there will be a new dialect of LiveCode in which you will be able to write things called extensions. An extension will (in the first instance) either be a library or a widget - [http://livecode.com/the-present-and-future-livecode/ livecode.com]","type":"paragraph"},{"id":"afddcba834ce05ba","text":"Libraries are collections of commands and functions that integrate into the engine in exactly the same way as engine commands and functions do (the only caveat being initially is that you will be restricted to generic function / command call syntax to access them ‚Äì full and proper syntax bindings will have to wait until Open Language is born).","type":"paragraph"},{"id":"342b2f5e5d370ada","text":"Widgets are collections of commands, functions and event handlers ‚Äì these will be used by a new control type widget and allow you to create you own controls which look, feel and act as if they were in fact part of the engine itself. Indeed, widgets will be very familiar to anyone who has ever written a control in Visual Basic, Delphi, or derived a new control from the base control class in any of the multiplicity of C++ GUI frameworks. This idea of controls is different from the aggregate style of custom control we currently see in LiveCode ‚Äì rather than using a container in which you put other controls you instead get a ‚Äòpaint‚Äô event and all the basic interaction events you need to craft your control entirely the way you want. To help you do this, you‚Äôll also have access to an array of functionality crafted for the task ‚Äì most importantly, you‚Äôll be able to use a collection of syntax that provides 2d vector drawing capabilities along the lines of the HTML5 Canvas, or CoreGraphics library to draw your widgets.","type":"paragraph"},{"id":"4bc105c8384b3034","text":"I mentioned above that this will be based upon a ‚Äònew dialect‚Äô of LiveCode (I‚Äôm currently calling it LiveCodeish) but this shouldn‚Äôt cause alarm bells (hopefully, at least). Essentially the dialect will be a distilled form of the current LiveCode core syntax and semantics ‚Äì this syntax will be cleaned up and its functionality will be much better defined (for example, getting rid of auto-conversion of arrays to empty strings and ‚Äòfixing‚Äô the non-standard ‚Äòfor x to y‚Äô loop we have). The main aim of this clean up is to ensure we have a solid, predictable, reliable and completely defined base to work from without having to worry about any hangovers from the (very much organically evolved) past.","type":"paragraph"},{"id":"f5a94b223227d9a5","text":"[ I think it is important for me to mention is that we do not intend there to be two LiveCode languages - the language you use for extensions (what I‚Äôm calling LiveCodeish) and the language you use in object scripts. It is our intention that there will be one, and only one, LiveCode - the object script language will also move to LiveCodeish, once we‚Äôre happy we‚Äôve got LiveCodeish right (and don‚Äôt worry, when LiveCodeish does arrive at the LiveCode script level your existing scripts will all continue to run as they do now and you‚Äôll be able to translate them automatically over time as needed with the script translation tool we are planning as part of the syntax cleanup project that will be enabled by [[Open Language]]). ]","type":"paragraph"},{"id":"c133a85c1c0a355a","text":"There are perhaps three aspects of this proposed new LiveCodeish language which deserve mention.\n\nThe first is that this new dialect will provide the ability to directly hook into native code through binding to functions in native code (whether that be Java, Objective-C or C/C++) thus, hopefully, eliminating the need to write ‚Äòglue-code‚Äô externals and, again, making extending LiveCode much more accessible to anyone that can code in LiveCode rather than those few who can, or have the time to delve into these lower-level environments.\n\nThe next is that it will (eventually) be typed in a very natural way. You will be able to declare variables and handler parameters as having a given type (by default their type will be any). Whenever you try to assign a value to the variable the engine will attempt to convert it to the appropriate type and only throw an error if this is not possible. For example a variable with an integer type can have an integer put into it directly, a real number can be put into it after its been automatically rounded, and even a string can ‚Äì as long as the string can be converted to an integer. This simple ability will mean that it will be easier to write ‚Äòcorrect‚Äô code ‚Äì you‚Äôll be able to much more easily debug things where it could be type-mismatches that are causing errors. It also means that (in the future) suitably typed code will run more efficiently ‚Äì for example if you have an integer variable then that can be much more efficiently represented internally than a variable which can hold any type.\n\nThe third thing about LiveCodeish which is quite different from normal LiveCode scripts is that there is no message path ‚Äì well, the message path is there, it‚Äôs just that command and functions in extensions do not sit in it. This is exactly the same situation as current engine commands and functions ‚Äì they are bound at compile time. This not sitting in the message path does not mean that extensions have no access to it, quite the reverse as they will have access in the same way as engine syntax does ‚Äì you will be able to send messages to objects through the message path just as the engine can. This slight change in perspective brings LiveCodeish much closer to more ‚Äòtraditional‚Äô languages ‚Äì and means that over time a much larger range of optimization potential becomes available (as things are more static in this world ‚Äì dynamicity is great, except when you want to optimize at compile time!). Indeed, I can see no reason that LiveCodeish should not be eventually compilable to native code with performance at a level where the decision to code something in C or LiveCodeish due to that metric is a non-issue ‚Äì LiveCodeish will be amply able.","type":"paragraph"}],"title":"LiveCode Builder"}